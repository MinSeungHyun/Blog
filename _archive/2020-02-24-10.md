---
title: 'LineMemo'
header:
  teaser: https://grepp-cloudfront.s3.ap-northeast-2.amazonaws.com/programmers_imgs/competition-imgs/2020-LINE-Challenge/LINE_PRGM_SNS-Thumbnail-edited.png
sidebar:
  - title: 장소
    text: 온라인(프로그래머스)
  - title: Github
    link: https://github.com/MinSeungHyun/line-memo
  - text: 라인 신입 개발자 채용 앱 개발 챌린지
date_from: 2020-02-10
date_to: 2020-02-24
types: [0, 1]
---

{% include figure image_path="https://grepp-cloudfront.s3.ap-northeast-2.amazonaws.com/programmers_imgs/competition-imgs/2020-LINE-Challenge/LINE_PRGM_SNS-Thumbnail-edited.png" %}

아직까진 혼자 개발할 일이 많다보니 다른 사람이 내 코드를 보고 피드백 받을 일이 거의 없었다.  
그러다 프로그래머스에서 라인 앱 개발 챌린지를 발견했는데, 내 코드를 리뷰받을 수 있는 좋은 기회라고 생각해서 참여하게 되었다.  
마침 지원 대상이 경력 2년 미만의 앱 개발자여서 나에게 적합하다고 생각했다.

지원 방법이 간단해서 이름, 이메일 등 기본적인 정보만 적으면 바로 시작할 수 있었다.  
지정된 기한(2020-02-24)까지 주어진 앱을 만들어서 제출하면 된다.

### 앱 세부사항 (조건)

- 언어: Java, Kotlin 중 택1
- minSdkVersion: 21
- targetSdkVersion: 27 이상
- 라이브러리 사용: 필요시 외부 라이브러리 사용이 가능하며, 사용시 출처(링크)를 주석으로 포함주세요. 단, AndroidX, Google 라이브러리는 출처를 적지 않아도 됩니다.

#### 기능 요구사항

##### 기능1: 메모 리스트

1.  로컬 영역에 저장된 메모를 읽어 리스트 형태로 화면에 표시합니다.
2.  리스트에서는 메모에 첨부되어 있는 이미지의 썸네일, 제목, 글의 일부가 보여집니다. (이미지가 n개일 경우, 첫 번째 이미지가 썸네일이 되어야 함)
3.  리스트의 메모를 선택하면 메모 상세 보기 화면으로 이동합니다.
4.  새 메모 작성하기 기능을 통해 메모 작성화면으로 이동할 수 있습니다.

##### 기능2: 메모 상세 보기

1.  작성된 메모의 제목과 본문을 볼 수 있습니다.
2.  메모에 첨부되어 있는 이미지를 볼 수 있습니다. (이미지는 n개 존재 가능)
3.  메뉴를 통해 메모 내용 편집 또는 삭제가 가능합니다.

##### 기능3: 메모 편집 및 작성

1.  제목 입력란과 본문 입력란, 이미지 첨부란이 구분되어 있어야 합니다. (글 중간에 이미지가 들어갈 수 있는 것이 아닌, 첨부된 이미지가 노출되는 부분이 따로 존재)
2.  이미지 첨부란의 '추가' 버븐을 통해 이미지 첨부가 가능합니다. 첨부할 이미지는 다음 중 한가지 방법을 선택하여 추가할 수 있습니다. 이미지는 0개이상 첨부할 수 있습니다. 외부 이미지의 경우, 이미지를 가져올 수 없는 경우(URL이 잘못되었거나)에 대한 처리도 필요합니다.
3.  편집 시에는 기존에 첨부된 이미지가 나타나며, 이미지를 더 추가하거나 기존 이미지를 삭제할 수 있습니다.

## 디자인

디자인에 대한 사항은 주어지지 않아서 우선 디자인을 어떻게 할지 생각해봤다.

1. 처음 앱을 실행하면 메모 리스트 화면이 보여지고, 우측 아래에 있는 FAB(Floating Action Button)을 누르면 메모 작성 화면으로 넘어간다.
2. 메모 리스트에서 아이템을 누르면 메모 상세 보기 화면으로 넘어간다.
3. 메모 상세 보기 화면에서 ActionBar에 있는 수정 버튼을 누르면 메모 편집 화면으로 넘어간다.

메모 편집 및 작성 화면은 하나의 Activity로 처리하는 게 좋을 것 같고, 메모 상세 보기 화면을 어떻게 할지 두가지 선택지가 생긴다.

1. 메모 상세 보기 Activity를 따로 만든다.
2. 메모 편집 및 작성 화면에서 메모 상세 보기까지 구현한다.

1번 방법으로 하면 개발자 입장에선 편한데 사용자 입장에선 새로운 화면으로 전환되는 과정에서 불편함을 느낄 것이다.  
2번 방법으로 하면 사용자는 편하지만 보기 상태, 편집 상태를 하나의 액티비티에서 관리해야 하기 때문에 구조가 복잡해지고 코드가 한곳에 집약될 가능성이 있다.

> 개발자가 편하면 사용자가 귀찮고, 개발자가 귀찮으면 사용자가 편하다.

이런 맥락의 글을 어디선가 본 것이 기억났다.  
그리고 대부분의 메모 앱이 2번 방법으로 하고 있다는 것을 발견해서 2번 방법으로 구현 하기로 결정했다.

## 구현

MVVM이라는 것을 공부한지 얼마 안됐을 때여서 실제 프로젝트에 써볼 기회가 없었다.  
그래서 이번 기회에 제대로 구현해보기로 마음 먹었다.

앱에서 필요한 액티비티는 두개이다.

1. ListActivity: 처음 실행했을 때 나오는 액티비티. DB에 저장된 메모들을 RecyclerView로 띄어준다.
2. EditActivity: 메모를 작성 / 수정 / 삭제 하거나 ListActivity에서 메모를 클릭하면 메모 상세정보를 보여줄 액티비티.

## 난관

개발 중 만난 몇 가지 문제점들, 난관들을 해결한 과정

### 첫 번째: MVVM에서의 이벤트 처리

MVVM 구조에서는 ViewModel이 View에 대한 종속성이 있으면 안된다.  
여기서 한가지 난관에 봉착했다.  
ListActivity에서 메모 추가 버튼을 누르면 ListViewModel에서 그 이벤트를 받는데, ViewModel에는 View에 대한 종속성을 넣을 수 없어서 `startActivity`를 할 수가 없었다.  
구글링을 해보다가 몇가지 방법을 찾았다.  
우선 기초는 Activity에서 ViewModel를 관찰하다가 변화가 생기면 그에 따른 이벤트를 실행해주는 것이다.  
이를 구현하는 몇가지 방법이 있는데, 나는 그 중 Event wrapper 방식을 택했다.

```kotlin
// ListViewModel
private val _startActivity = MutableLiveData<Event<Boolean>>()
val startActivity: LiveData<Event<Boolean>> = _startActivity

fun onAddButtonClick() {
  _startActivity.value = Event(true)
}
```

```kotlin
// ListActivity
viewModel.startActivity.observe(this, EventObserver {
  startActivity(Intent(this, EditActivity::class.java))
})
```

챌린지가 끝난 이후에 블로그 글로 정리해놨다. [글 보기](https://seunghyun.in/android/6){:target="blank"}

### 두 번째: ListActivity에서 startActivityForResult를 쓰게 된 이유

ListActivity에서 메모 추가 버튼을 누르면 EditActivity가 시작되고, EditActivity에서 새로운 메모를 작성하면 `finish`되면서 다시 ListActivity가 보여진다.  
이 때 ListActivity는 새로운 메모가 추가되었다는 것을 인지하고 리스트를 업데이트 해야 한다.

가장 쉬운 방법은 ListActivity의 `onStart()`가 호출되면 메모 리스트를 다시 불러오는 것이다.
하지만 ListActivity의 `onStart()`는 메모 리스트에 변화가 없을 때도 호출될 가능성이 있고, 그 때마다 DB에서 리스트를 불러오는 작업을 다시 해야하기 때문에 매우 비효율적이다.

두 번째 방법은 ListActivity와 EditActivity가 공유하는 ViewModel을 만드는 것인데, 불필요한 ViewModel로 코드가 복잡해질 가능성이 있기에 좋은 방법은 아니다.

그래서 선택한 방법은 ListActivity에서 `startActivityForResult`로 EditActivity를 시작하는 것이다.

```kotlin
// ListActivity에서 EditActivity를 시작하고,
startActivityForResult(intent, REQUEST_CREATE_MEMO)
```

```kotlin
// EditActivity에서 새로운 메모를 저장한 후에 setResult 해주면,
private fun onMemoSaved(memo: Memo) {
  val intent = Intent().apply { putExtra(KEY_MEMO_ITEM, memo) }
  setResult(Activity.RESULT_OK, intent)
  finish()
}
```

```kotlin
// 다시 ListActivity에서 받아서 ViewModel에 전달해준다.
override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
  val memo = data?.getSerializableExtra(KEY_MEMO_ITEM) as? Memo
      ?: return super.onActivityResult(requestCode, resultCode, data)
  if (resultCode == Activity.RESULT_OK) {
    viewModel.onMemoCreated(memo)
  }
}
```

추후에 메모 수정, 삭제도 resultCode와 requestCode로 나눠서 구현했다. [코드 보기](https://github.com/MinSeungHyun/line-memo/blob/e673bb7eb5076d2583fe424a7506b92b4f8c0f47/app/src/main/java/com/seunghyun/linememo/ui/list/ListActivity.kt#L62-L73){:target="blank"}

### 아직 글 작성 중입니다..!

<!-- ### 세 번째

`MutableLiveData<Event<Boolean>>()`에서 `MutableLiveData<Event<Memo?>>()`로 바꾼 이유  
[디자인](#디자인)부분에서도 언급했듯이 EditActivity는 메모 작성 / 수정 / 상세보기 이렇게 세가지 기능을 가지고 있다. -->
